-- Create types
create type public.user_permission as enum (
	'howtos.create',
	'howtos.update',
	'howtos.delete',
	'howtos.moderate',
	'events.create',
	'events.update',
	'events.delete',
	'events.moderate',
	'map.create',
	'map.update',
	'map.delete',
	'map.moderate',
	'features.update',
	'branding.update'
);
create type public.user_role as enum ('user', 'moderator', 'admin');
create type public.how_to_difficulty as enum ('easy', 'medium', 'hard');
create type public.how_to_duration as enum ('short', 'medium', 'long');
create type public.feature as enum ('howtos', 'events', 'map', 'academy');
create type public.moderation_status as enum ('pending', 'approved', 'rejected');
-- Create tables
create table public.user_roles (
	id bigint generated by default as identity primary key,
	user_id uuid references auth.users on delete cascade not null,
	role user_role not null,
	unique (user_id, role)
);
create table public.role_permissions (
	id bigint generated by default as identity primary key,
	role user_role not null,
	permission user_permission not null,
	unique (role, permission)
);
create table public.feature_flags (
	id public.feature primary key,
	enabled boolean not null default false
);
create table public.user_types (
	slug text primary key,
	label text not null,
	is_default boolean not null default false
);
create unique index on public.user_types (is_default)
where is_default;
create table public.profiles (
	id uuid primary key references auth.users on delete cascade not null,
	email text not null,
	type text not null,
	display_name text not null default 'Display Name',
	description text not null default '',
	image text
);
create table public.branding (
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	name text not null,
	slogan text not null,
	color_theme text not null,
	radius double precision not null
);
create table public.howtos (
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	user_id uuid references public.profiles not null,
	title text not null,
	description text not null,
	image text not null,
	tags text [] not null,
	difficulty public.how_to_difficulty not null,
	duration public.how_to_duration not null,
	steps jsonb [] not null
);
create table public.howtos_useful(
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	user_id uuid references public.profiles not null,
	howto_id bigint references public.howtos not null
);
create table public.howtos_moderation(
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	howto_id bigint references public.howtos not null,
	status public.moderation_status not null,
	comment text not null
);
create table public.events (
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	user_id uuid references public.profiles not null,
	title text not null,
	description text not null,
	image text not null,
	tags text [] not null,
	date timestamp with time zone not null,
	location text not null
);
create table public.events_interested(
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	user_id uuid references public.profiles not null,
	event_id bigint references public.events not null
);
create table public.events_moderation(
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	event_id bigint references public.events not null,
	status public.moderation_status not null,
	comment text not null
);
create table public.map_pins (
	id uuid primary key references public.profiles on delete cascade not null,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	lng double precision not null,
	lat double precision not null
);
create table public.map_pins_moderation(
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	pin_id uuid references public.map_pins not null,
	status public.moderation_status not null,
	comment text not null
);
-- Create trigger and function
create function public.handle_new_user() returns trigger language plpgsql security definer
set search_path = public as $$ begin
insert into public.profiles (id, email, type, display_name)
values (
		new.id,
		new.email,
		(
			select slug
			from public.user_types
			where is_default = true
		),
		new.raw_user_meta_data->>'display_name'
	);
return new;
end;
$$;
create trigger on_auth_user_created
after
insert on auth.users for each row execute procedure public.handle_new_user();
create function public.get_howto_useful_count(howto_id bigint, user_id uuid) returns table (count bigint, has_useful boolean) language sql as $$
select count(*) as count,
	case
		when exists (
			select 1
			from public.howtos_useful
			where user_id = user_id
				and howto_id = howto_id
		) then true
		else false
	end as has_useful
from public.howtos_useful
where howto_id = howto_id;
$$;
create type public.user_type as (slug text, label text, is_default boolean);
create function public.update_user_types(types user_type []) returns void language plpgsql as $$
declare type user_type;
begin
delete from public.user_types
where true;
foreach type in array types loop
insert into public.user_types (slug, label, is_default)
values (type.slug, type.label, type.is_default);
end loop;
end;
$$;
create function public.get_event_interest_count(event_id bigint, user_id uuid) returns table (count bigint, has_interest boolean) language sql as $$
select count(*) as interest_count,
	case
		when exists (
			select 1
			from public.events_interested
			where user_id = user_id
				and event_id = event_id
		) then true
		else false
	end as has_interest
from public.events_interested
where event_id = event_id;
$$;
-- Create auth hook function
create or replace function public.custom_access_token_hook(event jsonb) returns jsonb language plpgsql stable as $$
declare claims jsonb;
user_role public.user_role;
begin -- Check if the user is marked as admin in the profiles table
select role into user_role
from public.user_roles
where user_id = (event->>'user_id')::uuid;
claims := event->'claims';
if user_role is not null then -- Set the claim
claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
else claims := jsonb_set(claims, '{user_role}', 'null');
end if;
-- Update the 'claims' object in the original event
event := jsonb_set(event, '{claims}', claims);
-- Return the modified or original event
return event;
end;
$$;
grant usage on schema public to supabase_auth_admin;
grant execute on function public.custom_access_token_hook to supabase_auth_admin;
revoke execute on function public.custom_access_token_hook
from authenticated,
	anon;
grant all on table public.user_roles to supabase_auth_admin;
revoke all on table public.user_roles
from authenticated,
	anon;
create policy "Allow auth admin to read user roles" ON public.user_roles as permissive for
select to supabase_auth_admin using (true)