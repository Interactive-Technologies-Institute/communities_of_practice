/* EVENTS */
create type public.event_status as enum (
	'voting_open',
	'no_one_voted',
	'scheduled',
	'ongoing',
	'completed'
);
create table public.events (
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
	user_id uuid references public.profiles not null,
	title text not null,
	description text not null,
	image text not null,
	recording_link text,
	transcription text,
	summary text,
	tags text [] not null,
	location text not null,
	date date,
	start_time time,
	end_time time,
	allow_voting boolean not null default false,
	voting_end_date date,
	voting_end_time time,
	status event_status,
	constraint end_after_start check (end_time > start_time)
);
alter table public.events
add column fts tsvector generated always as (
		to_tsvector('simple', title || ' ' || description)
	) stored;
create index events_fts on public.events using gin (fts);
create or replace function public.set_event_status_on_insert()
returns trigger as $$
begin
  if new.allow_voting = false and new.date is not null then
    new.status := 'scheduled';
  elsif new.allow_voting = true and new.voting_end_date is not null and new.voting_end_time is not null then
    new.status := 'voting_open';
  else
    new.status := null;
  end if;
  return new;
end;
$$ language plpgsql;
create trigger set_event_status_on_insert_trigger
before insert on public.events
for each row
execute function public.set_event_status_on_insert();
create or replace function public.set_event_status_on_update()
returns trigger as $$
begin
	if new.date is not null and new.end_time is not null
	and (new.date + new.end_time::time) < (now() at time zone 'Europe/Lisbon')then 
	new.status := 'completed';
	elsif new.date is not null and new.start_time is not null and new.end_time is not null
	and (new.date + new.start_time::time) < (now() at time zone 'Europe/Lisbon')
	and (new.date + new.end_time::time) > (now() at time zone 'Europe/Lisbon')then 
	new.status := 'ongoing';
	elsif new.date is not null and new.start_time is not null
	and (new.date + new.start_time::time) > (now() at time zone 'Europe/Lisbon')then 
	new.status := 'scheduled';
	elsif new.allow_voting and new.voting_end_date is not null and new.voting_end_time is not null and
    (new.voting_end_date + new.voting_end_time::time) > (now() at time zone 'Europe/Lisbon') then 
	new.status := 'voting_open';
	new.final_voting_option_id := null;
  end if;
	if not new.allow_voting then new.final_voting_option_id := null; end if;
  return new;
end;
$$ language plpgsql;
create trigger set_event_status_on_update_trigger
before update on public.events
for each row
execute function public.set_event_status_on_update();
create trigger handle_updated_at before
update on public.events for each row execute procedure moddatetime (updated_at);
create table public.events_moderation(
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	event_id bigint references public.events on delete cascade not null,
	user_id uuid references public.profiles not null,
	status public.moderation_status not null,
	comment text not null
);
create function public.handle_event_moderation_updates() returns trigger language plpgsql security definer as $$ begin
insert into public.events_moderation (event_id, user_id, status, comment)
values (
		new.id,
		new.user_id,
		'pending'::moderation_status,
		'Pending moderation'
	);
return new;
end;
$$;
create trigger on_events_insert
after
insert on public.events for each row execute procedure public.handle_event_moderation_updates();
/*create trigger on_events_update
after
update on public.events for each row execute procedure public.handle_event_moderation_updates();*/
create table public.events_interested(
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	user_id uuid references public.profiles not null,
	event_id bigint references public.events on delete cascade not null,
	unique (user_id, event_id)
);
create function public.get_event_interest_count(event_id bigint, user_id uuid default null) returns table (count bigint, has_interest boolean) language sql security definer as $$
select count(*) as interest_count,
	case
		when exists (
			select 1
			from public.events_interested
			where user_id = $2
				and event_id = $1
		) then true
		else false
	end as has_interest
from public.events_interested
where event_id = $1;
$$;
create view public.latest_events_moderation with (security_invoker = on) as
select distinct on (event_id) *
from public.events_moderation
order by event_id,
	inserted_at desc;
create view public.events_view with (security_invoker = on) as
select
    e.*,
    m.status as moderation_status,
    coalesce((
        select count(*)
        from public.events_interested ei
        where ei.event_id = e.id
    ), 0) as interests_count
from public.events e
left join public.latest_events_moderation m on e.id = m.event_id;
create view public.events_tags with (security_invoker = on) as
select unnest(tags) as tag,
	count(*) as count
from public.events
group by tag;
create table public.events_voting_options (
	id bigint generated by default as identity primary key,
	event_id bigint references public.events on delete cascade not null,
	date date not null,
	start_time time not null,
	end_time time not null,
	constraint valid_time_slot check (end_time > start_time)
);
create table public.events_votes (
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	user_id uuid references public.profiles on delete cascade not null,
	event_id bigint references public.events on delete cascade not null,
	voting_option_id bigint references public.events_voting_options on delete cascade not null,
	constraint one_vote_per_option unique (user_id, voting_option_id)
);
create view public.events_voting_summary_view as
select
	vo.event_id,
	vo.id as voting_option_id,
	vo.date,
	vo.start_time,
	vo.end_time,
	count(v.id) as vote_count
from public.events_voting_options vo
left join public.events_votes v on v.voting_option_id = vo.id
group by vo.event_id, vo.id, vo.date, vo.start_time, vo.end_time;
create function public.get_vote_option_count(voting_option_id bigint, user_id uuid default null) returns table (vote_count bigint, has_voted boolean) language sql security definer as $$
select
  count(*) as vote_count,
  exists (
    select 1
    from public.events_votes
    where voting_option_id = $1
      and (user_id = $2 or $2 is null and user_id = auth.uid())
  ) as has_voted
from public.events_votes
where voting_option_id = $1;
$$;
alter table public.events
add column final_voting_option_id bigint references public.events_voting_options;
create or replace function public.finalize_event_votes()
returns void
language plpgsql
as $$
declare
	ev_id bigint;
	option_id bigint;
begin
	for ev_id in
		select id
		from events
		where allow_voting
		  and voting_end_date is not null
		  and voting_end_time is not null
		  and (voting_end_date + voting_end_time::time) < now() AT TIME ZONE 'Europe/Lisbon'
		  and date is null
	loop
		select vo.id
		into option_id
		from events_voting_options vo
		join events_votes v on v.voting_option_id = vo.id
		where vo.event_id = ev_id
		group by vo.id, vo.date, vo.start_time
		order by count(v.id) desc, vo.date asc, vo.start_time asc
		limit 1;
		if option_id is not null then
			update events
			set date = (select date from events_voting_options where id = option_id),
			    start_time = (select start_time from events_voting_options where id = option_id),
			    end_time = (select end_time from events_voting_options where id = option_id),
			    final_voting_option_id = option_id
			where id = ev_id;
		else
			update events
			set status = 'no_one_voted'
			where id = ev_id;
		end if;
	end loop;
end;
$$;
select cron.schedule(
  'finalize event votes',
  '*/5 * * * *',
  $$ select public.finalize_event_votes(); $$
);
create or replace function public.update_event_statuses()
returns void
language plpgsql
as $$
declare
	now_lisbon timestamptz := now() at time zone 'Europe/Lisbon';
begin
	update public.events
	set status = 'completed'
	where date is not null and end_time is not null
	  and (date + end_time::time) < now_lisbon
	  and status is distinct from 'completed';
	update public.events
	set status = 'ongoing'
	where date is not null and start_time is not null and end_time is not null
	  and (date + start_time::time) <= now_lisbon
	  and (date + end_time::time) > now_lisbon
	  and status is distinct from 'ongoing';
	update public.events
	set status = 'scheduled'
	where date is not null and start_time is not null
	  and (date + start_time::time) > now_lisbon
	  and status is distinct from 'scheduled';
	update public.events
	set status = 'voting_open',
	    final_voting_option_id = null
	where allow_voting = true
	  and voting_end_date is not null and voting_end_time is not null
	  and (voting_end_date + voting_end_time::time) > now_lisbon
	  and status is distinct from 'voting_open';
	update public.events
	set final_voting_option_id = null
	where allow_voting = false
	  and final_voting_option_id is not null;
end;
$$;
select cron.schedule(
  'update event statuses',
  '*/5 * * * *', -- every 5 minutes
  $$ select public.update_event_statuses(); $$
);
-- Storage Buckets
insert into storage.buckets (id, name, public, allowed_mime_types)
values ('events', 'Events', true, '{"image/*"}');
-- RLS policies
alter table public.events enable row level security;
alter table public.events_moderation enable row level security;
alter table public.events_interested enable row level security;
alter table public.events_voting_options enable row level security;
alter table public.events_votes enable row level security;
create policy "Allow users to read approved events" on public.events for
select using (
		exists (
			select 1
			from public.events_moderation
			where event_id = events.id
				and status = 'approved'::public.moderation_status
		)
	);
create policy "Allow users to read their own events" on public.events for
select using (auth.uid() = user_id);
create policy "Allow users to create their own events" on public.events for
insert with check (
		(
			select authorize('events.create')
		)
		and auth.uid() = user_id
	);
create policy "Allow users to update their own events" on public.events for
update using (
		(
			select authorize('events.update')
		)
		and auth.uid() = user_id
	) with check (auth.uid() = user_id);
create policy "Allow users to delete their own events" on public.events for delete using (
	(
		select authorize('events.delete')
	)
	and auth.uid() = user_id
);
create policy "Allow moderators read all events" on public.events for
select using (
		(
			select authorize('events.moderate')
		)
	);
create policy "Allow moderators update all events" on public.events for
update using (
		(
			select authorize('events.moderate')
		)
	);
create policy "Allow moderators delete all events" on public.events for delete using (
	(
		select authorize('events.moderate')
	)
);
create policy "Allow users to read approved events moderation" on public.events_moderation for
select using (
		status = 'approved'::public.moderation_status
	);
create policy "Allow users to read their own events moderation" on public.events_moderation for
select using (auth.uid() = user_id);
create policy "Allow moderators to read all events moderation" on public.events_moderation for
select using (
		(
			select authorize('events.moderate')
		)
	);
create policy "Allow moderators to insert all events moderation" on public.events_moderation for
insert with check (
		(
			select authorize('events.moderate')
		)
	);
create policy "Allow users to read their own events interested" on public.events_interested for
select using (auth.uid() = user_id);
create policy "Allow users to create their own events interested" on public.events_interested for
insert with check (
		(
			select authorize('events.create')
		)
		and auth.uid() = user_id
	);
create policy "Allow users to delete their own events interested" on public.events_interested for delete using (
	(
		select authorize('events.delete')
	)
	and auth.uid() = user_id
);
create policy "Allow users to read all interests" on public.events_interested for
select using (true);
create policy "Allow users to read events voting options" on events_voting_options for
select using (true);
create policy "Allow users to insert event scheduling votes" on public.events_votes for
insert to authenticated with check (auth.uid() = user_id);
create policy "Allow users to vote on events voting options" on public.events_votes for
insert with check (
  auth.uid() = user_id
  and exists (
    select 1
    from public.events_voting_options o
    join public.events e on o.event_id = e.id
    where o.id = voting_option_id
      and e.voting_end_date is not null
      and e.voting_end_time is not null
      and (
        (e.voting_end_date + e.voting_end_time) > now()
      )
  )
);
create policy "Allow users to insert voting options to their own events"
  on public.events_voting_options
  for insert
  with check (
    exists (
      select 1 from public.events
      where id = event_id
        and user_id = auth.uid()
    )
);
create policy "Allow users to read their own votes" on public.events_votes for
select to authenticated using (auth.uid() = user_id);
create policy "Allow users can delete their own votes" on public.events_votes for
delete using (auth.uid() = user_id);
create policy "Allow users to upload images for their events" on storage.objects for
insert to authenticated with check (bucket_id = 'events');