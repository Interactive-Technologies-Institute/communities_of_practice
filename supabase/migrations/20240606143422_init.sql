/* GENERAL */
create extension if not exists moddatetime schema extensions;
create type public.moderation_status as enum (
	'pending',
	'changes_requested',
	'approved',
	'rejected'
);
/* AUTH & USERS*/
-- User roles & permissions
create type public.user_permission as enum (
	'howtos.create',
	'howtos.update',
	'howtos.delete',
	'howtos.moderate',
	'events.create',
	'events.update',
	'events.delete',
	'events.moderate',
	'map.create',
	'map.update',
	'map.delete',
	'map.moderate',
	'features.update',
	'branding.update',
	'user_types.update'
);
create type public.user_role as enum ('user', 'moderator', 'admin');
create table public.user_roles (
	id bigint generated by default as identity primary key,
	user_id uuid references auth.users on delete cascade not null,
	role user_role not null,
	unique (user_id, role)
);
create table public.role_permissions (
	id bigint generated by default as identity primary key,
	role user_role not null,
	permission user_permission not null,
	unique (role, permission)
);
create or replace function public.custom_access_token_hook(event jsonb) returns jsonb language plpgsql stable as $$
declare claims jsonb;
user_role public.user_role;
begin -- Check if the user is marked as admin in the profiles table
select role into user_role
from public.user_roles
where user_id = (event->>'user_id')::uuid;
claims := event->'claims';
if user_role is not null then -- Set the claim
claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
else claims := jsonb_set(claims, '{user_role}', 'null');
end if;
-- Update the 'claims' object in the original event
event := jsonb_set(event, '{claims}', claims);
-- Return the modified or original event
return event;
end;
$$;
grant usage on schema public to supabase_auth_admin;
grant execute on function public.custom_access_token_hook to supabase_auth_admin;
revoke execute on function public.custom_access_token_hook
from authenticated,
	anon;
grant all on table public.user_roles to supabase_auth_admin;
revoke all on table public.user_roles
from authenticated,
	anon;
create policy "Allow auth admin to read user roles" ON public.user_roles as permissive for
select to supabase_auth_admin using (true);
create or replace function public.authorize(requested_permission user_permission) returns boolean as $$
declare bind_permissions int;
user_role public.user_role;
begin -- Fetch user role once and store it to reduce number of calls
select (auth.jwt()->>'user_role')::public.user_role into user_role;
select count(*) into bind_permissions
from public.role_permissions
where role_permissions.permission = requested_permission
	and role_permissions.role = user_role;
return bind_permissions > 0;
end;
$$ language plpgsql stable security definer
set search_path = '';
-- User profiles
create table public.profiles (
	id uuid primary key references auth.users on delete cascade not null,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
	email text not null,
	type text not null,
	display_name text not null default 'Display Name',
	description text not null default '',
	image text
);
create function public.handle_new_user() returns trigger language plpgsql security definer
set search_path = public as $$ begin
insert into public.profiles (id, email, type, display_name)
values (
		new.id,
		new.email,
		(
			select slug
			from public.user_types
			where is_default = true
		),
		new.raw_user_meta_data->>'display_name'
	);
return new;
end;
$$;
create trigger on_auth_user_created
after
insert on auth.users for each row execute procedure public.handle_new_user();
create trigger handle_updated_at before
update on public.profiles for each row execute procedure moddatetime (updated_at);
-- RLS policies
alter table public.user_roles enable row level security;
alter table public.role_permissions enable row level security;
alter table public.profiles enable row level security;
create policy "Allow all users to read all profiles" on public.profiles for
select using (true);
create policy "Allow users to update their own profiles" on public.profiles for
update using (auth.uid() = id);
/* HOW TOS */
create type public.how_to_difficulty as enum ('easy', 'medium', 'hard');
create type public.how_to_duration as enum ('short', 'medium', 'long');
create table public.howtos (
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
	user_id uuid references public.profiles not null,
	title text not null,
	description text not null,
	image text not null,
	tags text [] not null,
	difficulty public.how_to_difficulty not null,
	duration public.how_to_duration not null,
	steps jsonb [] not null
);
create trigger handle_updated_at before
update on public.howtos for each row execute procedure moddatetime (updated_at);
create table public.howtos_moderation(
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
	howto_id bigint references public.howtos not null,
	status public.moderation_status not null,
	comment text not null
);
create trigger handle_updated_at before
update on public.howtos_moderation for each row execute procedure moddatetime (updated_at);
create function public.handle_how_to_moderation_insert() returns trigger language plpgsql as $$ begin
insert into public.howtos_moderation (howto_id, status, comment)
values (
		new.id,
		'pending'::moderation_status,
		'Pending moderation'
	);
return new;
end;
$$;
create trigger on_howtos_insert
after
insert on public.howtos for each row execute procedure public.handle_how_to_moderation_insert();
create function handle_how_to_moderation_update() returns trigger language plpgsql as $$ begin
update public.howtos_moderation
set status = 'pending'::moderation_status,
	comment = 'Pending moderation'
where howto_id = new.id;
return new;
end;
$$;
create trigger on_howtos_update
after
update on public.howtos for each row execute procedure handle_how_to_moderation_update();
create view public.howtos_approved as
select *
from public.howtos
where exists (
		select 1
		from public.howtos_moderation
		where howto_id = howtos.id
			and status = 'approved'::public.moderation_status
	);
create table public.howtos_useful(
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	user_id uuid references public.profiles not null,
	howto_id bigint references public.howtos not null
);
create function public.get_howto_useful_count(howto_id bigint, user_id uuid default null) returns table (count bigint, has_useful boolean) language sql as $$
select count(*) as count,
	case
		when exists (
			select 1
			from public.howtos_useful
			where user_id = user_id
				and howto_id = howto_id
		) then true
		else false
	end as has_useful
from public.howtos_useful
where howto_id = howto_id;
$$;
-- RLS policies
alter table public.howtos enable row level security;
alter table public.howtos_moderation enable row level security;
alter table public.howtos_useful enable row level security;
create policy "Allow users to read their own howtos" on public.howtos for
select using (auth.uid() = user_id);
create policy "Allow users to create their own howtos" on public.howtos for
insert with check (
		(
			select authorize('howtos.create')
		)
		and auth.uid() = user_id
	);
create policy "Allow users to update their own howtos" on public.howtos for
update using (
		(
			select authorize('howtos.update')
		)
		and auth.uid() = user_id
	);
create policy "Allow users to delete their own howtos" on public.howtos for delete using (
	(
		select authorize('howtos.delete')
	)
	and auth.uid() = user_id
);
create policy "Allow moderators read all howtos" on public.howtos for
select using (
		(
			select authorize('howtos.moderate')
		)
	);
create policy "Allow moderators update all howtos" on public.howtos for
update using (
		(
			select authorize('howtos.moderate')
		)
	);
create policy "Allow moderators delete all howtos" on public.howtos for delete using (
	(
		select authorize('howtos.moderate')
	)
);
create policy "Allow users to read their own howtos moderation" on public.howtos_moderation for
select using (
		auth.uid() = (
			select user_id
			from public.howtos
			where id = howto_id
		)
	);
create policy "Allow moderators to read all howtos moderation" on public.howtos_moderation for
select using (
		(
			select authorize('howtos.moderate')
		)
	);
create policy "Allow moderators to update all howtos moderation" on public.howtos_moderation for
update using (
		(
			select authorize('howtos.moderate')
		)
	);
create policy "Allow users to read their own howtos useful" on public.howtos_useful for
select using (auth.uid() = user_id);
create policy "Allow users to read all approved howtos useful" on public.howtos_useful for
select using (
		exists (
			select 1
			from public.howtos_moderation
			where howto_id = public.howtos_useful.howto_id
				and status = 'approved'::public.moderation_status
		)
	);
create policy "Allow users to create their own howtos useful" on public.howtos_useful for
insert with check (
		(
			select authorize('howtos.create')
		)
		and auth.uid() = user_id
	);
create policy "Allow users to delete their own howtos useful" on public.howtos_useful for delete using (
	(
		select authorize('howtos.delete')
	)
	and auth.uid() = user_id
);
/* EVENTS */
create table public.events (
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
	user_id uuid references public.profiles not null,
	title text not null,
	description text not null,
	image text not null,
	tags text [] not null,
	date timestamp with time zone not null,
	location text not null
);
create trigger handle_updated_at before
update on public.events for each row execute procedure moddatetime (updated_at);
create table public.events_moderation(
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
	event_id bigint references public.events not null,
	status public.moderation_status not null,
	comment text not null
);
create trigger handle_updated_at before
update on public.events_moderation for each row execute procedure moddatetime (updated_at);
create table public.events_interested(
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	user_id uuid references public.profiles not null,
	event_id bigint references public.events not null
);
create function public.handle_event_moderation_insert() returns trigger language plpgsql as $$ begin
insert into public.events_moderation (event_id, status, comment)
values (
		new.id,
		'pending'::moderation_status,
		'Pending moderation'
	);
return new;
end;
$$;
create trigger on_events_insert
after
insert on public.events for each row execute procedure public.handle_event_moderation_insert();
create function handle_event_moderation_update() returns trigger language plpgsql as $$ begin
update public.events_moderation
set status = 'pending'::moderation_status,
	comment = 'Pending moderation'
where event_id = new.id;
return new;
end;
$$;
create trigger on_events_update
after
update on public.events for each row execute procedure handle_event_moderation_update();
create view public.events_approved as
select *
from public.events
where exists (
		select 1
		from public.events_moderation
		where event_id = events.id
			and status = 'approved'::public.moderation_status
	);
create function public.get_event_interest_count(event_id bigint, user_id uuid default null) returns table (count bigint, has_interest boolean) language sql as $$
select count(*) as interest_count,
	case
		when exists (
			select 1
			from public.events_interested
			where user_id = user_id
				and event_id = event_id
		) then true
		else false
	end as has_interest
from public.events_interested
where event_id = event_id;
$$;
-- RLS policies
alter table public.events enable row level security;
alter table public.events_moderation enable row level security;
alter table public.events_interested enable row level security;
create policy "Allow users to read their own events" on public.events for
select using (auth.uid() = user_id);
create policy "Allow users to create their own events" on public.events for
insert with check (
		(
			select authorize('events.create')
		)
		and auth.uid() = user_id
	);
create policy "Allow users to update their own events" on public.events for
update using (
		(
			select authorize('events.update')
		)
		and auth.uid() = user_id
	);
create policy "Allow users to delete their own events" on public.events for delete using (
	(
		select authorize('events.delete')
	)
	and auth.uid() = user_id
);
create policy "Allow moderators read all events" on public.events for
select using (
		(
			select authorize('events.moderate')
		)
	);
create policy "Allow moderators update all events" on public.events for
update using (
		(
			select authorize('events.moderate')
		)
	);
create policy "Allow moderators delete all events" on public.events for delete using (
	(
		select authorize('events.moderate')
	)
);
create policy "Allow users to read their own events moderation" on public.events_moderation for
select using (
		auth.uid() = (
			select user_id
			from public.events
			where id = event_id
		)
	);
create policy "Allow moderators to read all events moderation" on public.events_moderation for
select using (
		(
			select authorize('events.moderate')
		)
	);
create policy "Allow moderators to update all events moderation" on public.events_moderation for
update using (
		(
			select authorize('events.moderate')
		)
	);
create policy "Allow users to read their own events interested" on public.events_interested for
select using (auth.uid() = user_id);
create policy "Allow users to read all approved events interested" on public.events_interested for
select using (
		exists (
			select 1
			from public.events_moderation
			where event_id = public.events_interested.event_id
				and status = 'approved'::public.moderation_status
		)
	);
create policy "Allow users to create their own events interested" on public.events_interested for
insert with check (
		(
			select authorize('events.create')
		)
		and auth.uid() = user_id
	);
create policy "Allow users to delete their own events interested" on public.events_interested for delete using (
	(
		select authorize('events.delete')
	)
	and auth.uid() = user_id
);
/* MAP */
create table public.map_pins (
	id uuid primary key references public.profiles on delete cascade not null,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
	lng double precision not null,
	lat double precision not null
);
create trigger handle_updated_at before
update on public.map_pins for each row execute procedure moddatetime (updated_at);
create table public.map_pins_moderation(
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	pin_id uuid references public.map_pins not null,
	status public.moderation_status not null,
	comment text not null
);
create trigger handle_updated_at before
update on public.map_pins_moderation for each row execute procedure moddatetime (updated_at);
-- RLS policies
alter table public.map_pins enable row level security;
alter table public.map_pins_moderation enable row level security;
create policy "Allow users to read their own map pins" on public.map_pins for
select using (auth.uid() = id);
create policy "Allow users to read approved map pins" on public.map_pins for
select using (
		exists (
			select 1
			from public.map_pins_moderation
			where pin_id = public.map_pins.id
				and status = 'approved'::public.moderation_status
		)
	);
create policy "Allow users to create their own map pins" on public.map_pins for
insert with check (
		(
			select authorize('map.create')
		)
		and auth.uid() = id
	);
create policy "Allow users to update their own map pins" on public.map_pins for
update using (
		(
			select authorize('map.update')
		)
		and auth.uid() = id
	);
create policy "Allow users to delete their own map pins" on public.map_pins for delete using (
	(
		select authorize('map.delete')
	)
	and auth.uid() = id
);
create policy "Allow moderators read all map pins" on public.map_pins for
select using (
		(
			select authorize('map.moderate')
		)
	);
create policy "Allow moderators update all map pins" on public.map_pins for
update using (
		(
			select authorize('map.moderate')
		)
	);
create policy "Allow moderators delete all map pins" on public.map_pins for delete using (
	(
		select authorize('map.moderate')
	)
);
create policy "Allow users to read their own map pins moderation" on public.map_pins_moderation for
select using (
		auth.uid() = (
			select id
			from public.map_pins
			where id = pin_id
		)
	);
create policy "Allow moderators to read all map pins moderation" on public.map_pins_moderation for
select using (
		(
			select authorize('map.moderate')
		)
	);
create policy "Allow moderators to update all map pins moderation" on public.map_pins_moderation for
update using (
		(
			select authorize('map.moderate')
		)
	);
/* ADMIN */
-- Features
create type public.feature as enum ('howtos', 'events', 'map', 'academy');
create table public.feature_flags (
	id public.feature primary key,
	enabled boolean not null default false
);
-- Branding
create table public.branding (
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
	name text not null,
	slogan text not null,
	color_theme text not null,
	radius double precision not null
);
create trigger handle_updated_at before
update on public.branding for each row execute procedure moddatetime (updated_at);
-- User types
create table public.user_types (
	slug text primary key,
	label text not null,
	is_default boolean not null default false
);
create unique index on public.user_types (is_default)
where is_default;
create type public.user_type as (slug text, label text, is_default boolean);
create function public.update_user_types(types user_type []) returns void language plpgsql as $$
declare type user_type;
begin
delete from public.user_types
where true;
foreach type in array types loop
insert into public.user_types (slug, label, is_default)
values (type.slug, type.label, type.is_default);
end loop;
end;
$$;
-- RLS policies
alter table public.feature_flags enable row level security;
alter table public.user_types enable row level security;
alter table public.branding enable row level security;
create policy "Allow all users to read features" on public.feature_flags for
select using (true);
create policy "Allow all users to read branding" on public.branding for
select using (true);
create policy "Allow all users to read user types" on public.user_types for
select using (true);
create policy "Allow admins to update features" on public.feature_flags for
update using (
		(
			select authorize('features.update')
		)
	);
create policy "Allow admins to update branding" on public.branding for
update using (
		(
			select authorize('branding.update')
		)
	);
create policy "Allow admins to create user types" on public.user_types for
insert with check (
		(
			select authorize('user_types.update')
		)
	);
create policy "Allow admins to delete user types" on public.user_types for delete using (
	(
		select authorize('user_types.update')
	)
);
/* REQUIRED SEED DATA */
insert into public.role_permissions (role, permission)
values ('user', 'howtos.create'),
	('user', 'howtos.update'),
	('user', 'howtos.delete'),
	('user', 'events.create'),
	('user', 'events.update'),
	('user', 'events.delete'),
	('user', 'map.create'),
	('user', 'map.update'),
	('user', 'map.delete'),
	('moderator', 'howtos.create'),
	('moderator', 'howtos.update'),
	('moderator', 'howtos.delete'),
	('moderator', 'howtos.moderate'),
	('moderator', 'events.create'),
	('moderator', 'events.update'),
	('moderator', 'events.delete'),
	('moderator', 'events.moderate'),
	('moderator', 'map.create'),
	('moderator', 'map.update'),
	('moderator', 'map.delete'),
	('moderator', 'map.moderate'),
	('admin', 'howtos.create'),
	('admin', 'howtos.update'),
	('admin', 'howtos.delete'),
	('admin', 'howtos.moderate'),
	('admin', 'events.create'),
	('admin', 'events.update'),
	('admin', 'events.delete'),
	('admin', 'events.moderate'),
	('admin', 'map.create'),
	('admin', 'map.update'),
	('admin', 'map.delete'),
	('admin', 'map.moderate'),
	('admin', 'features.update'),
	('admin', 'branding.update');
insert into public.feature_flags (id, enabled)
values ('howtos'::public.feature, true),
	('events'::public.feature, true),
	('map'::public.feature, true),
	('academy'::public.feature, true);
insert into public.user_types (slug, label, is_default)
values ('morador', 'Morador', true),
	('tecnico', 'Técnico', false),
	('multiplicador', 'Multiplicador', false),
	('parceiro', 'Parceiro', false);
insert into public.branding (name, slogan, color_theme, radius)
values (
		'Community',
		'A community for everyone',
		'neutral',
		0.5
	);