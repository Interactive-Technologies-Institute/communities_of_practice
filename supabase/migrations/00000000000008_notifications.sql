/* NOTIFICATIONS */
create type public.notification_type as enum (
	'guide_pending',
	'guide_changes_requested',
	'guide_approved',
	'guide_rejected',
	'event_pending',
	'event_pending_moderation',
	'event_changes_requested',
	'event_approved',
	'event_rejected',
	'event_announcement',
	'event_voting_closed',
	'event_voting_closed_no_votes',
	'event_voting_reopened',
	'map_pin_pending',
	'map_pin_changes_requested',
	'map_pin_approved',
	'map_pin_rejected',
	'forum_thread_pending',
	'forum_thread_changes_requested',
	'forum_thread_approved',
	'forum_thread_rejected',
	'forum_thread_announcement'
);
create table public.notifications (
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	user_id uuid references public.profiles not null,
	type public.notification_type not null,
	data jsonb default '{}'::jsonb not null,
	read boolean not null default false
);
create or replace function public.handle_guides_moderation_notification() returns trigger as $$
declare notification_type notification_type;
begin if new.status = 'pending' then notification_type := 'guide_pending';
elsif new.status = 'changes_requested' then notification_type := 'guide_changes_requested';
elsif new.status = 'approved' then notification_type := 'guide_approved';
elsif new.status = 'rejected' then notification_type := 'guide_rejected';
end if;
insert into public.notifications (user_id, type, data)
values (
		new.user_id,
		notification_type,
		jsonb_build_object('guide_id', new.guide_id)
	);
return new;
end;
$$ language plpgsql security definer;
create trigger guide_notification_trigger
after
insert on public.guides_moderation for each row execute function public.handle_guides_moderation_notification();
create or replace function public.handle_events_moderation_notification() returns trigger as $$
declare notification_type notification_type;
begin 
 if new.status = 'pending' then notification_type := 'event_pending';
    insert into public.notifications (user_id, type, data)
    select
      p.id,
      'event_pending_moderation',
      jsonb_build_object('event_id', new.event_id)
    from public.profiles p
    where p.id != new.user_id
      and exists (
        select 1
        from public.user_roles ur
        where ur.id = p.id
          and ur.role = 'moderator' or ur.role = 'admin'
      );
elsif new.status = 'changes_requested' then notification_type := 'event_changes_requested';
elsif new.status = 'approved' then
		insert into public.notifications (user_id, type, data)
		values (
			new.user_id,
			'event_approved',
			jsonb_build_object('event_id', new.event_id)
		);
		insert into public.notifications (user_id, type, data)
		select
			p.id,
			'event_announcement',
			jsonb_build_object('event_id', new.event_id)
		from public.profiles p
		where p.id != new.user_id;
elsif new.status = 'rejected' then notification_type := 'event_rejected';
end if;

if new.status != 'approved' then 
	insert into public.notifications (user_id, type, data)
	values (
			new.user_id,
			notification_type,
			jsonb_build_object('event_id', new.event_id)
		);
end if;
return new;
end;
$$ language plpgsql security definer;
create trigger event_notification_trigger
after
insert on public.events_moderation for each row execute function public.handle_events_moderation_notification();
create or replace function public.handle_event_voting_closed_notification()
returns trigger as $$
declare
  creator_id uuid;
begin
  if not old.voting_closed and old.final_voting_option_id is null and new.final_voting_option_id is null and new.voting_closed then
    select user_id into creator_id from public.events where id = new.id;
    insert into public.notifications (user_id, type, data)
    values (
      creator_id,
      'event_voting_closed_no_votes',
      jsonb_build_object('event_id', new.id)
    );
  elsif not old.voting_closed and new.voting_closed and new.final_voting_option_id is not null then
    insert into public.notifications (user_id, type, data)
    select
      p.id,
      'event_voting_closed',
      jsonb_build_object('event_id', new.id)
    from public.profiles p;
  end if;
  return new;
end;
$$ language plpgsql security definer;
create trigger event_voting_closed_trigger
after update on public.events
for each row
execute function public.handle_event_voting_closed_notification();
create or replace function public.handle_event_voting_reopened_notification()
returns trigger as $$
begin
	if (old.voting_end_date + old.voting_end_time::time) < (now() at time zone 'Europe/Lisbon')
	   and (new.voting_end_date + new.voting_end_time::time) > (now() at time zone 'Europe/Lisbon') then

		insert into public.notifications (user_id, type, data)
		select
			p.id,
			'event_voting_reopened',
			jsonb_build_object('event_id', new.id)
		from public.profiles p;
	end if;

	return new;
end;
$$ language plpgsql security definer;
create trigger event_voting_reopened_trigger
after update on public.events
for each row
execute function public.handle_event_voting_reopened_notification();
create or replace function public.handle_map_pins_moderation_notification() returns trigger as $$
declare notification_type notification_type;
begin if new.status = 'pending' then notification_type := 'map_pin_pending';
elsif new.status = 'changes_requested' then notification_type := 'map_pin_changes_requested';
elsif new.status = 'approved' then notification_type := 'map_pin_approved';
elsif new.status = 'rejected' then notification_type := 'map_pin_rejected';
end if;
insert into public.notifications (user_id, type, data)
values (
		new.user_id,
		notification_type,
		jsonb_build_object('map_pin_id', new.map_pin_id)
	);
return new;
end;
$$ language plpgsql security definer;
create trigger map_pin_notification_trigger
after
insert on public.map_pins_moderation for each row execute function public.handle_map_pins_moderation_notification();
create or replace function public.handle_forum_threads_moderation_notification() returns trigger as $$
declare
	notification_type notification_type;
begin
	if new.status = 'pending' then notification_type := 'forum_thread_pending';
	elsif new.status = 'changes_requested' then notification_type := 'forum_thread_changes_requested';
	elsif new.status = 'approved' then
		insert into public.notifications (user_id, type, data)
		values (
			new.user_id,
			'forum_thread_approved',
			jsonb_build_object('thread_id', new.thread_id)
		);
		insert into public.notifications (user_id, type, data)
		select
			p.id,
			'forum_thread_announcement',
			jsonb_build_object('thread_id', new.thread_id)
		from public.profiles p
		where p.id != new.user_id;
	elsif new.status = 'rejected' then
		notification_type := 'forum_thread_rejected';
	end if;
	if new.status != 'approved' then
		insert into public.notifications (user_id, type, data)
		values (
			new.user_id,
			notification_type,
			jsonb_build_object('thread_id', new.thread_id)
		);
	end if;
	return new;
end;
$$ language plpgsql security definer;
create trigger forum_thread_notification_trigger
after
insert on public.forum_threads_moderation for each row execute function public.handle_forum_threads_moderation_notification();
-- RLS policies
create policy "Allow users to read their own notifications" on public.notifications for
select using (user_id = auth.uid());