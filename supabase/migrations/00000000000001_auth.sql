/* AUTH & USERS */
-- User roles & permissions
create type public.user_permission as enum (
	'user_roles.update',
	'user_types.update',
	'features.update',
	'branding.update',
	'guides.create',
	'guides.update',
	'guides.delete',
	'guides.moderate',
	'events.create',
	'events.update',
	'events.delete',
	'events.moderate',
	'map.create',
	'map.update',
	'map.delete',
	'map.moderate',
	'forum_threads.create',
	'forum_threads.update',
	'forum_threads.delete',
	'forum_threads.moderate',
	'thread_comments.create',
	'thread_comments.update',
	'thread_comments.delete',
	'thread_comments.moderate',
	'contents.create',
	'contents.update',
	'contents.delete',
	'contents.moderate',
	'thread_contents.create',
	'thread_contents.delete',
	'thread_events.create',
	'thread_events.delete',
	'event_contents.create',
	'event_contents.delete'
);
create type public.user_role as enum ('user', 'moderator', 'admin');
create table public.user_roles (
	id uuid primary key references auth.users on delete cascade not null,
	role user_role not null,
	unique (id)
);
create table public.role_permissions (
	id bigint generated by default as identity primary key,
	role user_role not null,
	permission user_permission not null,
	unique (role, permission)
);
create or replace function public.custom_access_token_hook(event jsonb) returns jsonb language plpgsql stable as $$
declare claims jsonb;
user_role public.user_role;
begin -- Check if the user is marked as admin in the profiles table
select role into user_role
from public.user_roles
where id = (event->>'user_id')::uuid;
claims := event->'claims';
if user_role is not null then -- Set the claim
claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
else claims := jsonb_set(claims, '{user_role}', 'null');
end if;
-- Update the 'claims' object in the original event
event := jsonb_set(event, '{claims}', claims);
-- Return the modified or original event
return event;
end;
$$;
grant usage on schema public to supabase_auth_admin;
grant execute on function public.custom_access_token_hook to supabase_auth_admin;
revoke execute on function public.custom_access_token_hook
from authenticated,
	anon;
grant all on table public.user_roles to supabase_auth_admin;
create policy "Allow auth admin to read user roles" ON public.user_roles as permissive for
select to supabase_auth_admin using (true);
create or replace function public.authorize(requested_permission user_permission) returns boolean as $$
declare bind_permissions int;
user_role public.user_role;
begin -- Fetch user role once and store it to reduce number of calls
select (auth.jwt()->>'user_role')::public.user_role into user_role;
select count(*) into bind_permissions
from public.role_permissions
where role_permissions.permission = requested_permission
	and role_permissions.role = user_role;
return bind_permissions > 0;
end;
$$ language plpgsql stable security definer
set search_path = '';
create or replace function public.verify_user_password(password text) returns boolean security definer as $$ begin return exists (
		select id
		from auth.users
		where id = auth.uid()
			and encrypted_password = crypt(password::text, auth.users.encrypted_password)
	);
end;
$$ language plpgsql;
set search_path = extensions,
	public,
	auth;
-- User profiles
create table public.profiles (
	id uuid primary key references auth.users on delete cascade not null,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
	email text not null,
	type text not null,
	display_name text not null,
	description text,
	avatar text,
	date text,
	profession text,
	website text,
	gender text,
	nationality text,
	interests text [] not null default '{}',
	skills text [] not null default '{}',
	education text [] not null default '{}',
	languages text [] not null default '{}',
	unique (id)
);
create view public.profiles_view with (security_invoker = on) as
select p.*,
	roles.role
from public.profiles p
	left join public.user_roles roles on p.id = roles.id;
create function public.handle_new_user() returns trigger language plpgsql security definer
set search_path = public as $$ begin
insert into public.user_roles (id, role)
values (new.id, 'user');
insert into public.profiles (id, email, type, display_name)
values (
		new.id,
		new.email,
		(
			select slug
			from public.user_types
			where is_default = true
		),
		new.raw_user_meta_data->>'display_name'
	);
return new;
end;
$$;
create trigger on_auth_user_created
after
insert on auth.users for each row execute procedure public.handle_new_user();
create trigger handle_updated_at before
update on public.profiles for each row execute procedure moddatetime (updated_at);
-- Storage Buckets
insert into storage.buckets (id, name, public, allowed_mime_types)
values ('users', 'Users', true, '{"image/*"}');
-- RLS policies
alter table public.user_roles enable row level security;
alter table public.role_permissions enable row level security;
alter table public.profiles enable row level security;
create policy "Allow all users to read all user roles" on public.user_roles for
select using (true);
create policy "Allow admins to update user roles" on public.user_roles for
update using (
		(
			select authorize('user_roles.update')
		)
	);
create policy "Allow all users to read all profiles" on public.profiles for
select using (true);
create policy "Allow users to update their own profiles" on public.profiles for
update using (auth.uid() = id) with check (auth.uid() = id);
create policy "Allow users to manage their own files" on storage.objects for all using (
	bucket_id = 'users'
	AND (storage.foldername(name)) [1] = auth.uid()::text
) with check (
	bucket_id = 'users'
	AND (storage.foldername(name)) [1] = auth.uid()::text
);
-- Seed data
insert into public.role_permissions (role, permission)
values ('user', 'guides.create'),
	('user', 'guides.update'),
	('user', 'guides.delete'),
	('user', 'events.create'),
	('user', 'events.update'),
	('user', 'events.delete'),
	('user', 'map.create'),
	('user', 'map.update'),
	('user', 'map.delete'),
	('user', 'forum_threads.create'),
	('user', 'forum_threads.update'),
	('user', 'forum_threads.delete'),
	('user', 'thread_comments.create'),
	('user', 'thread_comments.update'),
	('user', 'thread_comments.delete'),
	('user', 'contents.create'),
	('user', 'contents.update'),
	('user', 'contents.delete'),
	('user', 'thread_contents.create'),
	('user', 'thread_contents.delete'),
	('user', 'thread_events.create'),
	('user', 'thread_events.delete'),
	('user', 'thread_threads.create'),
	('user', 'thread_threads.delete'),
	('user', 'event_contents.create'),
	('user', 'event_contents.delete'),
	('moderator', 'guides.create'),
	('moderator', 'guides.update'),
	('moderator', 'guides.delete'),
	('moderator', 'guides.moderate'),
	('moderator', 'events.create'),
	('moderator', 'events.update'),
	('moderator', 'events.delete'),
	('moderator', 'events.moderate'),
	('moderator', 'map.create'),
	('moderator', 'map.update'),
	('moderator', 'map.delete'),
	('moderator', 'map.moderate'),
	('moderator', 'forum_threads.create'),
	('moderator', 'forum_threads.update'),
	('moderator', 'forum_threads.delete'),
	('moderator', 'forum_threads.moderate'),
	('moderator', 'thread_comments.create'),
	('moderator', 'thread_comments.update'),
	('moderator', 'thread_comments.delete'),
	('moderator', 'thread_comments.moderate'),
	('moderator', 'contents.create'),
	('moderator', 'contents.update'),
	('moderator', 'contents.delete'),
	('moderator', 'contents.moderate'),
	('moderator', 'thread_contents.create'),
	('moderator', 'thread_contents.delete'),
	('moderator', 'thread_events.create'),
	('moderator', 'thread_events.delete'),
	('moderator', 'thread_threads.create'),
	('moderator', 'thread_threads.delete'),
	('moderator', 'event_contents.create'),
	('moderator', 'event_contents.delete'),
	('admin', 'user_roles.update'),
	('admin', 'user_types.update'),
	('admin', 'features.update'),
	('admin', 'branding.update'),
	('admin', 'guides.create'),
	('admin', 'guides.update'),
	('admin', 'guides.delete'),
	('admin', 'guides.moderate'),
	('admin', 'events.create'),
	('admin', 'events.update'),
	('admin', 'events.delete'),
	('admin', 'events.moderate'),
	('admin', 'map.create'),
	('admin', 'map.update'),
	('admin', 'map.delete'),
	('admin', 'map.moderate'),
	('admin', 'forum_threads.create'),
	('admin', 'forum_threads.update'),
	('admin', 'forum_threads.delete'),
	('admin', 'forum_threads.moderate'),
	('admin', 'thread_comments.create'),
	('admin', 'thread_comments.update'),
	('admin', 'thread_comments.delete'),
	('admin', 'thread_comments.moderate'),
	('admin', 'contents.create'),
	('admin', 'contents.update'),
	('admin', 'contents.delete'),
	('admin', 'contents.moderate'),
	('admin', 'thread_contents.create'),
	('admin', 'thread_contents.delete'),
	('admin', 'thread_events.create'),
	('admin', 'thread_events.delete'),
	('admin', 'thread_threads.create'),
	('admin', 'thread_threads.delete'),
	('admin', 'event_contents.create'),
	('admin', 'event_contents.delete');