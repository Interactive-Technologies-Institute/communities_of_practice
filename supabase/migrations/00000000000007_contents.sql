/* CONTENTS */
create table public.contents (
    id bigint generated by default as identity primary key,
    inserted_at timestamptz not null default timezone('utc', now()),
    updated_at timestamptz not null default timezone('utc', now()),
    user_id uuid references public.profiles on delete cascade not null,
    title text not null,
    description text,
    file text not null,
    mime_type text not null,
    tags text [] not null default '{}',
);
alter table public.contents
add column fts tsvector generated always as (
        to_tsvector('simple', title || ' ' || description)
    ) stored;
create index contents_fts on public.contents using gin (fts);
create trigger handle_updated_at before
update on public.contents for each row execute procedure moddatetime (updated_at);
create table public.contents_moderation (
    id bigint generated by default as identity primary key,
    inserted_at timestamptz default timezone('utc', now()) not null,
    content_id bigint references public.contents on delete cascade not null,
    user_id uuid references public.profiles not null,
    status public.moderation_status not null,
    comment text not null
);
create function public.handle_content_moderation_updates() returns trigger language plpgsql security definer as $$ begin
insert into public.contents_moderation (content_id, user_id, status, comment)
values (
        new.id,
        new.user_id,
        'pending'::moderation_status,
        'Pending moderation'
    );
return new;
end;
$$;
create trigger on_contents_insert
after
insert on public.contents for each row execute procedure public.handle_content_moderation_updates();
create table public.contents_downloaded(
    id bigint generated by default as identity primary key,
    inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
    user_id uuid references public.profiles not null,
    content_id bigint references public.contents on delete cascade not null,
    unique (user_id, content_id)
);
create function public.get_content_download_count(content_id bigint, user_id uuid default null) returns table (count bigint, has_download boolean) language sql security definer as $$
select count(*) as download_count,
    case
        when exists (
            select 1
            from public.contents_downloaded
            where user_id = $2
                and content_id = $1
        ) then true
        else false
    end as has_download
from public.contents_downloaded
where content_id = $1;
$$;
create view public.latest_contents_moderation with (security_invoker = on) as
select distinct on (content_id) *
from public.contents_moderation
order by content_id,
    inserted_at desc;
create or replace view public.contents_view
with (security_invoker = on) as
select
    c.*,
    case
        when c.mime_type like 'image/%' then 'Image'
        when c.mime_type like 'video/%' then 'Video'
        when c.mime_type like 'audio/%' then 'Audio'
        when c.mime_type like 'text/%' then 'Text'
        when c.mime_type = 'application/pdf' then 'PDF'
        when c.mime_type in (
            'application/zip',
            'application/x-7z-compressed',
            'application/x-rar-compressed',
            'application/x-tar'
        ) then 'Archive'
        when c.mime_type = 'application/json' then 'JSON'
        when c.mime_type in (
            'application/vnd.ms-excel',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        ) then 'Spreadsheet'
        when c.mime_type in (
            'application/msword',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        ) then 'Word Doc'
        else 'File'
    end as file_type,
    m.status as moderation_status,
    coalesce(
        (
            select count(*)
            from public.contents_downloaded cd
            where cd.content_id = c.id
        ),
        0
    ) as downloads_count
from public.contents c
left join public.latest_contents_moderation m on c.id = m.content_id;

create view public.contents_tags with (security_invoker = on) as
select unnest(tags) as tag,
    count(*) as count
from public.contents
group by tag;
-- Storage Buckets
insert into storage.buckets (id, name, public, allowed_mime_types)
values (
        'contents',
        'Contents',
        true,
        '{"image/*", "application/pdf", "application/zip", "application/msword", "application/vnd.*", "text/*"}'
    );
alter table public.contents enable row level security;
alter table public.contents_moderation enable row level security;
alter table public.contents_downloaded enable row level security;
create policy "Allow users to read approved contents" on public.contents for
select using (
        exists (
            select 1
            from public.contents_moderation
            where content_id = contents.id
                and status = 'approved'::public.moderation_status
        )
    );
create policy "Allow users to read their own contents" on public.contents for
select using (auth.uid() = user_id);
create policy "Allow users to create their own contents" on public.contents for
insert with check (
        (
            select authorize('contents.create')
        )
        and auth.uid() = user_id
    );
create policy "Allow users to update their own contents" on public.contents for
update using (
        (
            select authorize('contents.update')
        )
        and auth.uid() = user_id
    ) with check (auth.uid() = user_id);
create policy "Allow users to delete their own contents" on public.contents for delete using (
    (
        select authorize('contents.delete')
    )
    and auth.uid() = user_id
);
create policy "Allow moderators read all contents" on public.contents for
select using (
        (
            select authorize('contents.moderate')
        )
    );
create policy "Allow moderators update all contents" on public.contents for
update using (
        (
            select authorize('contents.moderate')
        )
    );
create policy "Allow moderators delete all contents" on public.contents for delete using (
    (
        select authorize('contents.moderate')
    )
);
create policy "Allow users to read their own contents downloaded" on public.contents_downloaded for
select using (auth.uid() = user_id);
create policy "Allow users to create their own contents downloaded" on public.contents_downloaded for
insert with check (
        (
            select authorize('contents.create')
        )
        and auth.uid() = user_id
    );
create policy "Allow users to delete their own contents downloaded" on public.contents_downloaded for delete using (
    (
        select authorize('contents.delete')
    )
    and auth.uid() = user_id
);
create policy "Allow users to read approved contents moderation" on public.contents_moderation for
select using (
		status = 'approved'::public.moderation_status
	);
create policy "Allow users to read their own contents moderation" on public.contents_moderation for
select using (auth.uid() = user_id);
create policy "Allow moderators to read all contents moderation" on public.contents_moderation for
select using (
		(
			select authorize('contents.moderate')
		)
	);
create policy "Allow moderators to insert all contents moderation" on public.contents_moderation for
insert with check (
		(
			select authorize('contents.moderate')
		)
	);
create policy "Allow users to read all download records" on public.contents_downloaded for
select using (true);
create policy "Allow users to upload files for their contents" on storage.objects for
insert to authenticated with check (bucket_id = 'contents');